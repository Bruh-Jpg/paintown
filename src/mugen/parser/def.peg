# mugen def parser
start-symbol: start
options: debug0
module: Mugen.Def
include: {{
#include "../ast/all.h"
typedef std::list<Ast::Section*> SectionList;
}}

code: {{

template<class X>
X as(const Value & value){
    return (X) value.getValue();
}

void addSection(const Value & section_list_value, const Value & section_value){
  SectionList * sections = (SectionList*) section_list_value.getValue();
  Ast::Section * section = (Ast::Section*) section_value.getValue();
  if (section == 0){
    std::cerr << "Cannot add null section" << std::endl;
    throw ParseException();
  }
  sections->push_back(section);
}

Ast::Section * makeSection(const Value & str){
  return new Ast::Section(as<std::string*>(str));
}

SectionList * makeSectionList(){
  return new SectionList();
}

std::string * toString(const Value & input){
  std::ostringstream out;
  for (Value::iterator it = input.getValues().begin(); it != input.getValues().end(); it++){
    out << (char) (long) (*it).getValue();
  }
  return new std::string(out.str());
}

std::string * toString(char front, const Value & input){
  std::string * str = toString(input);
  str->insert(str->begin(), front);
  return str;
}

Ast::Attribute * makeAttribute(const Value & id, const Value & data){
    return new Ast::AttributeSimple(as<Ast::Identifier*>(id), as<Ast::Value*>(data));
}

Ast::Attribute * makeAttributeFilename(const Value & id, const Value & data){
    return new Ast::Attribute();
}

Ast::Attribute * makeIndexedAttribute(const Value & id, const Value & index, const Value & data){
    return new Ast::Attribute();
}

Ast::Attribute * makeAttributes(const Value & id, const Value & data){
    return new Ast::Attribute();
}

Ast::Value * makeValue(){
    return new Ast::Value(1.0);
}

Ast::Identifier * makeIdentifier(const Value & front, const Value & rest){
    std::list<std::string*> ids;
    ids.push_back(as<std::string*>(front));
    for (Value::iterator it = rest.getValues().begin(); it != rest.getValues().end(); it++){
        ids.push_back(as<std::string*>((*it).getValue()));
    }
    return new Ast::Identifier(ids);
}

Ast::Section * asSection(const Value & value){
    return as<Ast::Section*>(value);
}

Ast::Attribute * asAttribute(const Value & value){
    return as<Ast::Attribute*>(value);
}

Ast::Value * asValue(const Value & value){
    return as<Ast::Value*>(value);
}

}}

rules:
	start = current:{{ value = makeSectionList(); }} whitespace newline* (line(current) whitespace line_end?)* <eof> {{ value = $1; }}
    # start = current real_start($1)
    # real_start(c) = blah ... <eof>
    #               | {{ delete c; }} <error>
    # or
    # start = current{{..}} blah .. <eof> <fail>{{ delete current.getValue(); }}
	line(current) = s comment
	              | s section {{ addSection(current, $2); }}
	     # | s characters
	     #| s attribute {{ value = current; }}
	     #| s valuelist {{ value = current; }}
	     #| s loopstart {{ value = current; }}
	              | space+
	line_end = newline+
	         | &<eof> <void>
	inline newline = "\n"
                   | "\r"
	whitespace = sw*
	sw = " "
	   | "\t"
	   | comment
	s = space*
	inline space = " "
	             | "\t"
	inline comment = ";" (!"\n" .)*
	               | "=" (!"\n" .)*
		           | "-" "-"+
	section = section_start ast:{{value = makeSection($1);}} whitespace line_end+ (section_line(ast) whitespace line_end)* {{ value = ast; }}
    section_line(section) = s comment
                          | s data:attribute {{ asSection(section)->addAttribute(asAttribute(data)); }}
                          | s data:valuelist {{ asSection(section)->addValue(asValue(data)); }}
                          | s data:loopstart {{ asSection(section)->addValue(asValue(data)); }}
                          | space+ !"["
    section_start = "[" s data:(!"]" .)+ s "]" {{ value = toString(data); }}
	loopstart = "loopstart"{case} {{ value = makeValue(); }}
	name = letter alpha_digit* {{ value = toString((char)(long)$1.getValue(),$2); }}
	inline letter = [abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_]
	alpha_digit = letter
	            | digit
	# characters = name s "," s filename
	filename = !<quote> filename_char+
	filename_char = !"," !"\n" !"[" .
	attribute = id:identifier s "=" s data:valuelist {{ value = makeAttribute(id, data); }}
	          | id:identifier s "=" s data:filename {{ value = makeAttributeFilename(id, data); }}
		      | id:identifier s "(" s index:number s ")" s "=" s data:valuelist {{ value = makeIndexedAttribute(id, index, data); }}
		      | id:identifier_list s "=" s data:valuelist {{ value = makeAttributes(id, data); }}
	identifier = name ("." name)* {{ value = makeIdentifier($1,$2); }}
	identifier_list = identifier (s "," s filename)+
	valuelist = value (s "," s value?)* {{ value = makeValue(); }}
	value = string
	      | date
	      | number
	      | "s"{case} !letter !"."
	      | "h"{case} !letter !"."
	      | "a"{case} number? !letter
          | filename
	date = digit+ "." digit+ "." digit+
	string = <quote> (!<quote> !"\n" .)* <quote>
	number = sign? float_or_integer
	inline sign = "+"
	            | "-"
	float_or_integer = digit* "." digit+
	                 | digit+ !"."
	inline digit = [0123456789]
