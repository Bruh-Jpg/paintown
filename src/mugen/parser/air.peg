start-symbol: start
options: debug0
module: Mugen.Air
include: {{
#include "../ast/all.h"
#include <map>
#include "gc.h"
typedef std::list<Ast::Section*> SectionList;
}}
code: {{
template<class X>
X as(const Value & value){
    return (X) value.getValue();
}

std::string * toString(const Value & input){
  std::ostringstream out;
  for (Value::iterator it = input.getValues().begin(); it != input.getValues().end(); it++){
    out << (char) (long) (*it).getValue();
  }
  return new std::string(out.str());
}

Ast::String * makeString(std::string * str){
    return new Ast::String(str);
}

Ast::String * makeString(const Value & value){
    return new Ast::String(toString(value));
}

Ast::Section * makeSection(const Value & str){
  return new Ast::Section(as<std::string*>(str));
}

Ast::Keyword * makeKeyword(const Value & value){
    return new Ast::Keyword(as<char*>(value));
}

Ast::Value * makeValueList(const Value & front, const Value & rest){
    std::list<Ast::Value*> values;
    values.push_back(as<Ast::Value*>(front));
    for (Value::iterator it = rest.getValues().begin(); it != rest.getValues().end(); it++){
        Ast::Value * value = as<Ast::Value*>((*it).getValue());
        if (value == 0){
            /* FIXME! replace empty with a new node */
            value = makeKeyword("empty");
            GC::save(as<Ast::Keyword*>(value));
            values.push_back(value);
        } else {
            values.push_back(value);
        }
    }
    return new Ast::ValueList(values);
}

Ast::Value * makeNumber(const Value & sign, const Value & number){
    double value = *(as<double*>(number));
    if (sign.getValue() != 0){
        value = -value;
    }

    return new Ast::Number(value);
}

double * parseDouble(const Value & value){
    std::string * str = toString(value);
    std::istringstream get(*str);
    double * number = new double;
    get >> *number;
    delete str;
    return number;
}

std::string * makeHeader(const Value & begin, const Value & action, const Value & num){
    std::ostringstream out;
    std::string * temp = toString(begin);
    out << *temp;
    delete temp;
    temp = toString(action);
    out << " " << *temp;
    delete temp;
    out << (as<Ast::Value*>(num))->toString();
    return new std::string(out.str()); 
}

SectionList * makeSectionList(){
  return new SectionList();
}

void addSection(const Value & section_list_value, const Value & section_value){
  SectionList * sections = (SectionList*) section_list_value.getValue();
  Ast::Section * section = (Ast::Section*) section_value.getValue();
  if (section == 0){
    throw ParseException("Cannot add null section");
  }
  sections->push_back(section);
}

Ast::Attribute * makeAttributeKeyword(const Value & id, const Value & data){
    return new Ast::AttributeKeyword(as<Ast::Keyword*>(id), as<Ast::Value*>(data));
}

}}

rules:
	start = current:{{ value = makeSectionList(); GC::save(as<SectionList*>(value)); }} whitespace newline* (line(current) whitespace line_end?)* <eof> {{ value = current; GC::cleanup(as<SectionList*>(value)); }}

	line(current) = s comment
	              | s action {{ addSection(current, $1); }}
    action = action_start ast:{{value = makeSection($1); GC::save(as<Ast::Section*>(value)); }} whitespace newline+ (action_line whitespace line_end)* {{ value = ast; }}
    action_line = s comment
	            | s collision_default
	            | s collision
	            | s valuelist
	            | s loopstart
	              # | space+
	line_end = newline+
	         | &<eof> <void>
	newline = "\n"
	        | "\r"
	loopstart = "loopstart"{case} {{ value = makeKeyword($1); GC::save(as<Ast::Keyword*>(value)); }}
	whitespace = sw*
	sw = space
	   | comment
	s = space*
	space = " "
	      | "\t"
	      | <ascii 255>
	comment = ";" (!"\n" .)*
	        | "=" (!"\n" .)*
		    | "-" "-"+
	collision_default = "Clsn2Default:"{case} s num:integer {{ value = makeKeyword($1); GC::save(as<Ast::Keyword*>(value)); value = makeAttributeKeyword(value, num); GC::save(as<Ast::Attribute*>(value)); }}
	                  | "Clsn1Default:"{case} s num:integer
	                  | "Clsn2:"{case} s num:integer
			          | "Clsn1:"{case} s num:integer
	collision = "Clsn2"{case} s "[" s digit+ s "]" s "=" s integer s "," s integer s "," s integer s "," s integer
	          | "Clsn1"{case} s "[" s digit+ s "]" s "=" s integer s "," s integer s "," s integer s "," s integer
	action_start = "[" s begin:"Begin"{case} s action:"Action"{case} s num:integer s "]" {{ value = makeHeader(begin, action, num); GC::save(as<std::string*>(value)); }}
	digit = [0123456789]
	integer = sign? digit+ {{ value = parseDouble($2); GC::save(as<double*>(value)); value = makeNumber($1,value); GC::save(as<Ast::Number*>(value)); }}
	sign = "-"
	     | "+"
	valuelist = value (s "," s value?)* {{ value = makeValueList($1,$2); GC::save(as<Ast::Value*>(value)); }}

	value = integer
          # Are all these things part of .air files?
	      | "as"{case} integer "d"{case} integer
	      | "a"{case} integer
	      | "a"{case}
	      | "s"{case}
	      | "vh"{case}
	      | "hv"{case}
	      | "v"{case}
	      | "h"{case}
	valuev = value
	       | <void>
