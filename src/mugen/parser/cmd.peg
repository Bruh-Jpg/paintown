start-symbol: start
options: debug0
module: Mugen.Cmd
include: {{
#include "mugen/ast/all.h"
#include <map>
#include "gc.h"
typedef std::list<Ast::Section*> SectionList;
}}

code: {{

template<class X>
X as(const Value & value){
    return (X) value.getValue();
}

std::string * toString(const Value & input){
  std::ostringstream out;
  for (Value::iterator it = input.getValues().begin(); it != input.getValues().end(); it++){
    out << (char) (long) (*it).getValue();
  }
  std::string * object = new std::string(out.str());
  GC::save(object);
  return object;
}

std::string combineStrings(const Value & input){
    std::ostringstream out;
    for (Value::iterator it = input.getValues().begin(); it != input.getValues().end(); it++){
        std::string * str = (std::string *) (*it).getValue();
        out << *str;
    }
    return out.str();
}

std::string * toString(const char * x){
    std::string * object = new std::string(x);
    GC::save(object);
    return object;
}

Ast::Value * makeInteger(const Value & sign, const Value & digits){
    std::istringstream in(*toString(digits));
    double value = 0;
    in >> value;

    if (sign.getValue() != 0){
        value = -value;
    }
    
    Ast::Number * object = new Ast::Number(value);
    GC::save(object);
    return object;
}

std::string * toString(char front, const Value & input){
  std::string * str = toString(input);
  str->insert(str->begin(), front);
  return str;
}

Ast::String * makeString(const Value & value){
    Ast::String * object = new Ast::String(toString(value));
    GC::save(object);
    return object;
}

SectionList * makeSectionList(){
    SectionList * object = new SectionList();
    GC::save(object);
    return object;
}

Ast::Value * makeExpression(){
    Ast::Value * object = new Ast::Expression();
    GC::save(object);
    return object;
}

Ast::Value * makeKeyword(const char * name){
    Ast::Value * keyword = new Ast::Keyword(name);
    GC::save(keyword);
    return keyword;
}

Ast::Value * makeExpressionInfix(Ast::ExpressionInfix::InfixType type, const Value & left, const Value & right){
    Ast::Value * object = new Ast::ExpressionInfix(type, as<Ast::Value*>(left), as<Ast::Value*>(right));
    GC::save(object);
    return object;
}

Ast::Value * makeExpressionOr(const Value & left, const Value & right){
    return makeExpressionInfix(Ast::ExpressionInfix::Or, left, right);
}

Ast::Value * makeExpressionBitwiseOr(const Value & left, const Value & right){
    return makeExpressionInfix(Ast::ExpressionInfix::BitwiseOr, left, right);
}

Ast::Value * makeExpressionBitwiseXOr(const Value & left, const Value & right){
    return makeExpressionInfix(Ast::ExpressionInfix::BitwiseXOr, left, right);
}

Ast::Value * makeExpressionBitwiseAnd(const Value & left, const Value & right){
    return makeExpressionInfix(Ast::ExpressionInfix::BitwiseAnd, left, right);
}

Ast::Value * makeExpressionAssignment(const Value & left, const Value & right){
    return makeExpressionInfix(Ast::ExpressionInfix::Assignment, left, right);
}

Ast::Value * makeExpressionEquals(const Value & left, const Value & right){
    return makeExpressionInfix(Ast::ExpressionInfix::Equals, left, right);
}

Ast::Value * makeExpressionUnequals(const Value & left, const Value & right){
    return makeExpressionInfix(Ast::ExpressionInfix::Unequals, left, right);
}

Ast::Value * makeExpressionGreaterThanEquals(const Value & left, const Value & right){
    return makeExpressionInfix(Ast::ExpressionInfix::GreaterThanEquals, left, right);
}

Ast::Value * makeExpressionGreaterThan(const Value & left, const Value & right){
    return makeExpressionInfix(Ast::ExpressionInfix::GreaterThan, left, right);
}

Ast::Value * makeExpressionLessThanEquals(const Value & left, const Value & right){
    return makeExpressionInfix(Ast::ExpressionInfix::LessThanEquals, left, right);
}

Ast::Value * makeExpressionLessThan(const Value & left, const Value & right){
    return makeExpressionInfix(Ast::ExpressionInfix::LessThan, left, right);
}

Ast::Value * makeExpressionXOr(const Value & left, const Value & right){
    return makeExpressionInfix(Ast::ExpressionInfix::XOr, left, right);
}

Ast::Value * makeExpressionAnd(const Value & left, const Value & right){
    return makeExpressionInfix(Ast::ExpressionInfix::And, left, right);
}

Ast::Value * makeExpressionAdd(const Value & left, const Value & right){
    return makeExpressionInfix(Ast::ExpressionInfix::Add, left, right);
}

Ast::Value * makeExpressionSubtract(const Value & left, const Value & right){
    return makeExpressionInfix(Ast::ExpressionInfix::Subtract, left, right);
}

Ast::Value * makeExpressionMultiply(const Value & left, const Value & right){
    return makeExpressionInfix(Ast::ExpressionInfix::Multiply, left, right);
}

Ast::Value * makeExpressionDivide(const Value & left, const Value & right){
    return makeExpressionInfix(Ast::ExpressionInfix::Divide, left, right);
}

Ast::Value * makeExpressionModulo(const Value & left, const Value & right){
    return makeExpressionInfix(Ast::ExpressionInfix::Modulo, left, right);
}

Ast::Value * makeExpressionPower(const Value & left, const Value & right){
    return makeExpressionInfix(Ast::ExpressionInfix::Power, left, right);
}

Ast::Value * makeUnaryExpression(const Value & unaries, const Value & exp){
    Ast::Value * expression = as<Ast::Value*>(exp);
    for (Value::iterator it = unaries.getValues().begin(); it != unaries.getValues().end(); it++){
        Ast::ExpressionUnary::UnaryType unary = (Ast::ExpressionUnary::UnaryType) (long) (*it).getValue();
        expression = new Ast::ExpressionUnary(unary, expression);
        GC::save(expression);
    }
    return expression;
}

Ast::Value * makeFunction(const Value & name, const Value & arg1){
    Ast::Value * function = new Ast::Function(std::string(as<const char*>(name)), as<Ast::Value*>(arg1));
    GC::save(function);
    return function;
}

Ast::Value * makeFunction(const Value & name, const Value & arg1, const Value & arg2, const Value & arg3){
    Ast::Value * function = new Ast::Function(std::string(as<const char*>(name)),
                                              as<Ast::Value*>(arg1),
                                              as<Ast::Value*>(arg2),
                                              as<Ast::Value*>(arg3));
    GC::save(function);
    return function;
}

Ast::Value * makeRange(Ast::Range::RangeType type, const Value & low, const Value & high){
    Ast::Value * range = new Ast::Range(type, as<Ast::Value*>(low), as<Ast::Value*>(high));
    GC::save(range);
    return range;
}

Ast::Identifier * makeIdentifier(const Value & front, const Value & rest){
    std::list<std::string> ids;
    ids.push_back(*as<std::string*>(front));
    for (Value::iterator it = rest.getValues().begin(); it != rest.getValues().end(); it++){
        /* this works becuase as() will coerce a void* into Value(void*) */
        ids.push_back(*as<std::string*>((*it).getValue()));
    }
    Ast::Identifier * object = new Ast::Identifier(ids);
    GC::save(object);
    return object;
}

Ast::Attribute * makeAttribute(const Value & id, const Value & data){
    Ast::AttributeSimple * object = new Ast::AttributeSimple(as<Ast::Identifier*>(id), as<Ast::Value*>(data));
    GC::save(object);
    return object;
}

Ast::Attribute * makeAttribute(const Value & id){
    Ast::AttributeSimple * object = new Ast::AttributeSimple(as<Ast::Identifier*>(id));
    GC::save(object);
    return object;
}

Ast::Attribute * makeIndexedAttribute(const Value & id, const Value & index, const Value & data){
    Ast::Attribute * object = new Ast::AttributeArray(as<Ast::Identifier*>(id), as<Ast::Value*>(index), as<Ast::Value*>(data));
    GC::save(object);
    return object;
}

Ast::Value * makeValueList(const Value & front, const Value & rest){
    std::list<Ast::Value*> values;
    values.push_back(as<Ast::Value*>(front));
    for (Value::iterator it = rest.getValues().begin(); it != rest.getValues().end(); it++){
        Ast::Value * value = as<Ast::Value*>((*it).getValue());
        if (value == 0){
            /* FIXME! replace empty with a new node */
            value = makeKeyword("empty");
            values.push_back(value);
        } else {
            values.push_back(value);
        }
    }

    Ast::ValueList * object = new Ast::ValueList(values);
    GC::save(object);
    return object;
}

Ast::Identifier * makeSimpleIdentifier(const Value & name){
    Ast::Identifier * identifier = new Ast::SimpleIdentifier(as<const char *>(name));
    GC::save(identifier);
    return identifier;
}

double * parseDouble(const Value & value){
    std::string * str = toString(value);
    std::istringstream get(*str);
    double * number = new double;
    get >> *number;
    GC::save(number);
    return number;
}

double * parseDouble(const Value & left, const Value & right){
    std::string * str1 = toString(left);
    std::string * str2 = toString(right);
    std::istringstream get(*str1 + "." + *str2);
    double * number = new double;
    get >> *number;
    GC::save(number);
    return number;
}

Ast::Identifier * makeSimpleIdentifier(const std::string & str){
    Ast::Identifier * identifier = new Ast::SimpleIdentifier(str);
    GC::save(identifier);
    return identifier;
}

Ast::Attribute * makeAttribute(const char * name, const Value & data){
    Ast::AttributeSimple * object = new Ast::AttributeSimple(makeSimpleIdentifier(std::string(name)), as<Ast::Value*>(data));
    GC::save(object);
    return object;
}

Ast::Value * makeNumber(const Value & sign, const Value & number){
    double value = *(as<double*>(number));
    if (sign.getValue() != 0 && strcmp(as<const char *>(sign), "-") == 0){
        value = -value;
    }

    Ast::Number * object = new Ast::Number(value);
    GC::save(object);
    return object;
}

void addSection(const Value & section_list_value, const Value & section_value){
    SectionList * sections = (SectionList*) section_list_value.getValue();
    Ast::Section * section = (Ast::Section*) section_value.getValue();
    if (section == 0){
            throw ParseException("Cannot add null section");
    }
    sections->push_back(section);
}

Ast::Section * makeSection(const Value & str){
    Ast::Section * object = new Ast::Section(as<std::string*>(str));
    GC::save(object);
    return object;
}

Ast::Key * makeKeyModifier(Ast::Key * in, Ast::KeyModifier::ModifierType type, int ticks = 0){
    Ast::Key * modded = new Ast::KeyModifier(type, in, ticks);
    GC::save(modded);
    return modded;
}

Ast::Key * makeKeyCombined(const Value & left, const Value & right){
    Ast::Key * key = new Ast::KeyCombined(as<Ast::Key*>(left), as<Ast::Key*>(right));
    GC::save(key);
    return key;
}
    
Ast::Key * makeKeyList(const Value & first, const Value & rest){
    std::vector<Ast::Key*> all;
    all.push_back(as<Ast::Key*>(first));

    for (Value::iterator it = rest.getValues().begin(); it != rest.getValues().end(); it++){
        Ast::Key * key = (Ast::Key*) (*it).getValue();
        all.push_back(key);
    }

    Ast::Key * object = new Ast::KeyList(all);
    GC::save(object);
    return object;
}

Ast::Key * makeKey(const Value & value){
    Ast::Key * key = new Ast::KeySingle(as<const char *>(value));
    GC::save(key);
    return key;
}

class KeyModifier{
public:
    virtual Ast::Key * apply(Ast::Key * in) = 0;
};

class ReleaseKeyModifier: public KeyModifier {
public:
    ReleaseKeyModifier(int ticks):
    ticks(ticks){
    }

    virtual Ast::Key * apply(Ast::Key * in){
        return makeKeyModifier(in, Ast::KeyModifier::Release, ticks);
    }

protected:

    int ticks;
};

class DirectionKeyModifier: public KeyModifier {
public:
    virtual Ast::Key * apply(Ast::Key * in){
        return makeKeyModifier(in, Ast::KeyModifier::Direction);
    }
};

class HeldDownKeyModifier: public KeyModifier {
public:
    virtual Ast::Key * apply(Ast::Key * in){
        return makeKeyModifier(in, Ast::KeyModifier::MustBeHeldDown);
    }
};

class OnlyKeyModifier: public KeyModifier {
public:
    virtual Ast::Key * apply(Ast::Key * in){
        return makeKeyModifier(in, Ast::KeyModifier::Only);
    }
};

Ast::Key * applyKeyModifiers(const Value & mods, Ast::Key * key){
    for (Value::iterator it = mods.getValues().begin(); it != mods.getValues().end(); it++){
        KeyModifier * modifier = (KeyModifier*) (*it).getValue();
        key = modifier->apply(key);
        delete modifier;
    }
    return key;
}

}}

rules:
	start = current:{{ value = makeSectionList(); }} whitespace newline* (line(current) whitespace line_end?)* <eof> {{ value = current; GC::cleanup(as<SectionList*>(value)); }} <fail> {{ GC::cleanup(0); }}
	line(current) = s comment
	              | s section {{ addSection(current, $2); }}
	line_end = newline+
	         | &<eof> <void>
	inline newline = "\n"
	               | "\r"
	whitespace = sw*
	sw = space
	   | comment
	s = space*
	inline space = " "
	             | "\t"
	comment = ";" (!"\n" .)*
	        | "=" (!"\n" .)*
		    | "-" "-"+
    section = section_title ast:{{ value = makeSection($1); }} whitespace newline+ (section_item(ast) whitespace line_end)* {{ value = ast; }}

    section_item(ast) = s comment
                      | s data:assignment {{ as<Ast::Section*>(ast)->addAttribute(as<Ast::Attribute*>(data)); }}
	section_title = "[" s name:(!"]" .)+ "]" {{ value = toString(name); }}
	assignment = "command"{case} s "=" s all:keys {{ value = makeAttribute("command", all); }}
               | name:identifier s "=" s exp:expr {{ value = makeAttribute(name, exp); }}
               | name:identifier s "=" s &line_end {{ value = makeAttribute(name); }}
	           | name:identifier s "(" s index:integer s ")" s "=" s exp:expr {{ value = makeIndexedAttribute(name, index, exp); }}
	identifier = first:name rest:("." name)* {{ value = makeIdentifier(first, rest); }}
	integer = sign? digit+ {{ value = makeInteger($1, $2); }}
	float = sign? left:digit* "." right:digit+ {{ value = makeNumber($1, parseDouble(left,right)); }}
          | sign? left:digit+ "." {{ value = makeNumber($1, parseDouble(left)); }}
	string = <quote> contents:(!<quote> !"\n" .)* <quote> {{ value = makeString(contents); }}
	inline sign = "-"
	            | "+"
    # [,] is inclusive
    # (,) is exclusive
	range = "[" s low:value s "," s high:value s "]" {{ value = makeRange(Ast::Range::AllInclusive, low, high); }}
	      | "(" s low:value s "," s high:value s ")" {{ value = makeRange(Ast::Range::AllExclusive, low, high); }}
	      | "(" s low:value s "," s high:value s "]" {{ value = makeRange(Ast::Range::LeftExclusiveRightInclusive, low, high); }}
	      | "[" s low:value s "," s high:value s ")" {{ value = makeRange(Ast::Range::LeftInclusiveRightExclusive, low, high); }}
	name = letter alpha_digit* {{ value = toString((char)(long)$1.getValue(),$2); }}
	inline letter = [abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_]
	alpha_digit = letter
	            | digit
	inline digit = [0123456789]
	
	valuelist = first:expr_c rest:(s "," s expr_c)+ {{ value = makeValueList(first, rest); }}
	          | s "," s first:expr_c rest:(s "," s expr_c)* {{ value = makeValueList(first, rest); }}

	expr = expr_c !(s ",") {{ value = $1; }}
	     | valuelist expr2_rest($1)

	expr_c = left:expr2 expr_rest(left)
	       # I dont think this is right
	       # | expr2_rest
	
    # Increasing order of precedence
	expr2 = left:expr3 expr2_rest(left)
	expr3 = left:expr4 expr3_rest(left)
	expr4 = left:expr5 expr4_rest(left)
	expr5 = left:expr6 expr5_rest(left)
	expr6 = left:expr7 expr6_rest(left)
	expr7 = left:expr8 expr7_rest(left)
	expr8 = left:expr9 expr8_rest(left)
	expr9 = left:expr10 expr9_rest(left)
	expr10 = left:expr11 expr10_rest(left)
	expr11 = left:expr12 expr11_rest(left)
	expr12 = left:expr13 expr12_rest(left)
	expr13 = unary* exp:expr13_real {{ value = makeUnaryExpression($1, exp); }}

	expr_rest(left) = s "||" s right:expr2 new_left:{{ value = makeExpressionOr(left, right); }} expr_rest(new_left)
	                | <void> {{ value = left; }}
	expr2_rest(left) = s "^^" s right:expr3 new_left:{{ value = makeExpressionXOr(left, right); }} expr2_rest(new_left)
	                 | <void> {{ value = left; }}
	expr3_rest(left) = s "&&" s right:expr4 new_left:{{ value = makeExpressionAnd(left, right); }} expr3_rest(new_left)
	                 | <void> {{ value = left; }}
	expr4_rest(left) = s "|" s right:expr5 new_left:{{ value = makeExpressionBitwiseOr(left, right); }} expr4_rest(new_left)
	                 | <void> {{ value = left; }}
	expr5_rest(left) = s "^" s right:expr6 new_left:{{ value = makeExpressionBitwiseXOr(left, right); }} expr5_rest(new_left)
	                 | <void> {{ value = left; }}
	expr6_rest(left) = s "&" s right:expr7 new_left:{{ value = makeExpressionBitwiseAnd(left, right); }} expr6_rest(new_left)
	                 | <void> {{ value = left; }}
	expr7_rest(left) = s ":=" s right:expr8 new_left:{{ value = makeExpressionAssignment(left, right); }} expr7_rest(new_left)
	                 | <void> {{ value = left; }}
	# todo: fix expr8_rest
	expr8_rest(left) = s "=" s right:expr9 new_left:{{ value = makeExpressionEquals(left, right); }} expr8_rest(new_left)
	                 | s "!=" s right:expr9 new_left:{{ value = makeExpressionUnequals(left, right); }} expr8_rest(new_left)
		             # todo: intervals
                             # but we have ranges.. dont need intervals
	                 | <void> {{ value = left; }}
	expr9_rest(left) = s maker:compare s right:expr10 new_left:{{ {
        typedef Ast::Value * (*compare_func)(const Value &, const Value &);
        value = as<compare_func>(maker)(left, right);
        }
    }} expr9_rest(new_left)
	                 | <void> {{ value = left; }}
	compare = "<=" {{ value = (void *) makeExpressionLessThanEquals; }}
		    | ">=" {{ value = (void *) makeExpressionGreaterThanEquals; }}
		    | "<" {{ value = (void *) makeExpressionLessThan; }}
	        | ">" {{ value = (void *) makeExpressionGreaterThan; }}
	all_compare = compare
	            | "="
		        | "!="
	expr10_rest(left) = s "+" s right:expr11 new_left:{{ value = makeExpressionAdd(left, right); }} expr10_rest(new_left)
	                  | s "-" s right:expr11 new_left:{{ value = makeExpressionSubtract(left, right); }} expr10_rest(new_left)
		              | <void> {{ value = left; }}
	expr11_rest(left) = s "*" s right:expr12 new_left:{{ value = makeExpressionMultiply(left, right); }} expr11_rest(new_left)
	                  | s "/" s right:expr12 new_left:{{ value = makeExpressionDivide(left, right); }} expr11_rest(new_left)
	                  | s "%" s right:expr12 new_left:{{ value = makeExpressionModulo(left, right); }} expr11_rest(new_left)
		              | <void> {{ value = left; }}
	expr12_rest(left) = s "**" s right:expr13 new_left:{{ value = makeExpressionPower(left, right); }} expr12_rest(new_left)
	                  | <void> {{ value = left; }}
	unary = "!" {{ value = (void*) Ast::ExpressionUnary::Not; }}
	      | "-" !digit {{ value = (void*) Ast::ExpressionUnary::Minus; }}
	      | "~" !key !digit {{ value = (void*) Ast::ExpressionUnary::Negation; }}
	expr13_real = function
	            | value
	            | "(" s e:expr s ")" {{ value = e; }}

    function = name:"abs"{case} s "(" s arg1:expr s ")"  {{ value = makeFunction(name, arg1); }}
	         | name:"const"{case} s "(" s arg1:expr s ")" {{ value = makeFunction(name, arg1); }}
		     | name:"selfanimexist"{case} s "(" s arg1:expr s ")" {{ value = makeFunction(name, arg1); }}
		     | name:"ifelse"{case} s "(" s arg1:expr_c s "," s arg2:expr_c s "," s arg3:expr_c s ")" {{ value = makeFunction("ifelse", arg1, arg2, arg3); }}
		     | name:"gethitvar"{case} s "(" s arg1:expr_c s ")" {{ value = makeFunction(name, arg1); }}
		     | name:"floor"{case} s "(" s arg1:expr_c s ")" {{ value = makeFunction(name, arg1); }}
		     | name:"ceil"{case} s "(" s arg1:expr_c s ")" {{ value = makeFunction(name, arg1); }}
		     | name:"sin"{case} s "(" s arg1:expr_c s ")" {{ value = makeFunction(name, arg1); }}
		     | name:"sysvar"{case} s "(" s arg1:integer s ")" {{ value = makeFunction(name, arg1); }}
		     | name:"var"{case} s "(" s arg1:integer s ")" {{ value = makeFunction(name, arg1); }}
		     | name:"numexplod"{case} s "(" s arg1:integer s ")" {{ value = makeFunction(name, arg1); }}
		     | name:"numhelper"{case} s "(" s arg1:integer s ")" {{ value = makeFunction(name, arg1); }}
		     | name:"numprojid"{case} s "(" s arg1:integer s ")" {{ value = makeFunction(name, arg1); }}
		     | name:"helper"{case} s "(" s arg1:integer s ")" {{ value = makeFunction(name, arg1); }}
		     | name:"fvar"{case} s "(" s arg1:integer s ")" {{ value = makeFunction(name, arg1); }}
		     | name:"enemynear"{case} s "(" s arg1:integer s ")" {{ value = makeFunction(name, arg1); }}
		     | name:"target"{case} s "(" s arg1:integer s ")" {{ value = makeFunction(name, arg1); }}
		     | name:"ishelper"{case} s "(" s arg1:integer s ")" {{ value = makeFunction(name, arg1); }}
		     | name:"animelemtime"{case} s "(" s arg1:expr_c s ")" {{ value = makeFunction(name, arg1); }}
		     | name:"animelemno"{case} s "(" s arg1:expr_c s ")" {{ value = makeFunction(name, arg1); }}
		     | name:"animexist"{case} s "(" s arg1:expr_c s ")" {{ value = makeFunction(name, arg1); }}
		     | name:"projguarded"{case} s "(" s arg1:expr_c s ")" {{ value = makeFunction(name, arg1); }}
		     | name:"projhittime"{case} s "(" s arg1:expr_c s ")" {{ value = makeFunction(name, arg1); }}
		     | name:"projcontact"{case} s "(" s arg1:expr_c s ")" s "=" s integer function_rest {{ value = makeExpression(); }}
		     | name:"animelem"{case} s "=" s arg1:integer function_rest {{
                /* FIXME: handle function rest */
                value = makeFunction(name, arg1);
             }}
		     | name:"numhelper"{case} s "(" s arg1:expr_c s ")" {{ value = makeFunction(name, arg1); }}
		     | name:"helper"{case} s "(" s arg1:expr_c s ")" {{ value = makeFunction(name, arg1); }}
	function_rest = s "," s all_compare s value
                  | <void>

    # Keys and key modifiers need their own AST structures
    keys = key_value_list
    key_value_list = first:key rest:(s "," s key)* {{ value = makeKeyList(first, rest); }}
	key = key_real ok:key_rest($1) !identifier {{ value = ok; }}
	key_rest(left) = s "+" another:key_real new_left:{{ value = makeKeyCombined(left, another); }} key_rest(new_left)
	               | <void> {{ value = left; }}
	key_real = mods:key_modifier* name:key_name {{ value = applyKeyModifiers(mods, makeKey(name)); }}
	key_modifier = "~" num:digit* {{ value = new ReleaseKeyModifier(*parseDouble(num)); }}
	             | "$" {{ value = new DirectionKeyModifier(); }}
		         | "/" {{ value = new HeldDownKeyModifier(); }}
		         | ">" {{ value = new OnlyKeyModifier(); }}
	key_name = "DB"
		     | "B"
		     | "DF"
		     | "D"
		     | "F"
		     | "UF"
		     | "UB"
		     | "U"
		     | "a"
		     | "b"
		     | "c"
		     | "x"
		     | "y"
		     | "z"
		     | "s"

	value = float
	      | integer
	      | keyword
	      | !keyword identifier
	      | range
	      | string
          | hitflag

    hitflag = "M-" {{ value = makeKeyword("M-"); }}
            | "A-" {{ value = makeKeyword("A-"); }}
	
	keyword = keyword_real !alpha_digit {{ value = $1; }}
	keyword_real = "vel"{case} s "y"{case} {{ value = makeKeyword("vel y"); }}
	             | "vel"{case} s "x"{case} {{ value = makeKeyword("vel x"); }}
	             | "pos"{case} s "y"{case} {{ value = makeKeyword("pos y"); }}
	             | "pos"{case} s "x"{case} {{ value = makeKeyword("pos x"); }}
	             | "p2dist"{case} s "x"{case} {{ value = makeKeyword("p2dist x"); }}
	             | "p2dist"{case} s "y"{case} {{ value = makeKeyword("p2dist y"); }}
	             | "p1dist"{case} s "x"{case} {{ value = makeKeyword("p1dist x"); }}
	             | "p1dist"{case} s "y"{case} {{ value = makeKeyword("p1dist y"); }}
	             | "p2bodydist"{case} s "x"{case} {{ value = makeKeyword("p2bodydist x"); }}
	             | "p2bodydist"{case} s "y"{case} {{ value = makeKeyword("p2bodydist y"); }}
	             | "p1bodydist"{case} s "x"{case} {{ value = makeKeyword("p1bodydist x"); }}
	             | "p1bodydist"{case} s "y"{case} {{ value = makeKeyword("p1bodydist y"); }}
	             | "parentdist"{case} s "x"{case} {{ value = makeKeyword("parentdist x"); }}
                 | "screenpos"{case} s "x"{case} {{ value = makeKeyword("screenpos x"); }}
                 | "screenpos"{case} s "y"{case} {{ value = makeKeyword("screenpos y"); }}
                 | hitflag
