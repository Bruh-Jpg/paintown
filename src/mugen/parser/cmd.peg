start-symbol: start
options: debug0
module: Mugen.Cmd
include: {{
#include "../ast/all.h"
#include <map>
#include "gc.h"
typedef std::list<Ast::Section*> SectionList;
}}

code: {{

template<class X>
X as(const Value & value){
    return (X) value.getValue();
}

std::string * toString(const Value & input){
  std::ostringstream out;
  for (Value::iterator it = input.getValues().begin(); it != input.getValues().end(); it++){
    out << (char) (long) (*it).getValue();
  }
  std::string * object = new std::string(out.str());
  GC::save(object);
  return object;
}

std::string * toString(char front, const Value & input){
  std::string * str = toString(input);
  str->insert(str->begin(), front);
  return str;
}

SectionList * makeSectionList(){
    SectionList * object = new SectionList();
    GC::save(object);
    return object;
}

Ast::Value * makeExpression(){
    Ast::Value * object = new Ast::Expression();
    GC::save(object);
    return object;
}

Ast::Value * makeExpressionInfix(Ast::ExpressionInfix::InfixType type, const Value & left, const Value & right){
    Ast::Value * object = new Ast::ExpressionInfix(type, as<Ast::Value*>(left), as<Ast::Value*>(right));
    GC::save(object);
    return object;
}

Ast::Value * makeExpressionOr(const Value & left, const Value & right){
    return makeExpressionInfix(Ast::ExpressionInfix::Or, left, right);
}

Ast::Value * makeExpressionAnd(const Value & left, const Value & right){
    return makeExpressionInfix(Ast::ExpressionInfix::And, left, right);
}

Ast::Identifier * makeIdentifier(const Value & front, const Value & rest){
    std::list<std::string*> ids;
    ids.push_back(as<std::string*>(front));
    for (Value::iterator it = rest.getValues().begin(); it != rest.getValues().end(); it++){
        ids.push_back(as<std::string*>((*it).getValue()));
    }
    Ast::Identifier * object = new Ast::Identifier(ids);
    GC::save(object);
    return object;
}

Ast::Attribute * makeAttribute(const Value & id, const Value & data){
    Ast::AttributeSimple * object = new Ast::AttributeSimple(as<Ast::Identifier*>(id), as<Ast::Value*>(data));
    GC::save(object);
    return object;
}

void addSection(const Value & section_list_value, const Value & section_value){
    SectionList * sections = (SectionList*) section_list_value.getValue();
    Ast::Section * section = (Ast::Section*) section_value.getValue();
    if (section == 0){
            throw ParseException("Cannot add null section");
    }
    sections->push_back(section);
}

Ast::Section * makeSection(const Value & str){
    Ast::Section * object = new Ast::Section(as<std::string*>(str));
    GC::save(object);
    return object;
}

}}

rules:
	start = current:{{ value = makeSectionList(); }} whitespace newline* (line(current) whitespace line_end?)* <eof> {{ value = current; GC::cleanup(as<SectionList*>(value)); }} <fail> {{ GC::cleanup(0); }}
	line(current) = s comment
	              | s section {{ addSection(current, $2); }}
	line_end = newline+
	         | &<eof> <void>
	inline newline = "\n"
	               | "\r"
	whitespace = sw*
	sw = space
	   | comment
	s = space*
	inline space = " "
	             | "\t"
	comment = ";" (!"\n" .)*
	        | "=" (!"\n" .)*
		    | "-" "-"+
    section = section_title ast:{{ value = makeSection($1); }} whitespace newline+ (section_item(ast) whitespace line_end)* {{ value = ast; }}

    section_item(ast) = s data:assignment {{ as<Ast::Section*>(ast)->addAttribute(as<Ast::Attribute*>(data)); }}
	section_title = "[" s name:(!"]" .)+ "]" {{ value = toString(name); }}
	assignment = name:identifier s "=" s exp:expr {{ value = makeAttribute(name, exp); }}
	           | name:identifier s "(" s index:integer s ")" s "=" s exp:expr {{ value = makeAttribute(name, exp); }}
	identifier = first:name rest:("." name)* {{ value = makeIdentifier(first, rest); }}
	integer = sign? digit+
	string = <quote> (!<quote> !"\n" .)* <quote>
	float = sign? digit* "." digit+
	      | sign? digit+ "."
	inline sign = "-"
	            | "+"
	range = "[" s valuelist s "]"
	      | "(" s valuelist s ")"
	      | "(" s valuelist s "]"
	      | "[" s valuelist s ")"
	name = letter alpha_digit* {{ value = toString((char)(long)$1.getValue(),$2); }}
	inline letter = [abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_]
	alpha_digit = letter
	            | digit
	inline digit = [0123456789]
	
	valuelist = expr_c (s "," s expr_c)*
	          | s "," s expr_c ("," s expr_c)*

	expr = expr_c !(s ",") {{ value = $1; }}
	     | valuelist {{ value = makeExpression(); }}

	expr_c = left:expr2 expr_rest(left)
	       # I dont think this is right
	       # | expr2_rest
	
	expr2 = left:expr3 expr2_rest(left)
	expr3 = left:expr4 expr3_rest(left)
	expr4 = left:expr5 expr4_rest {{ value = makeExpression(); }}
	expr5 = left:expr6 expr5_rest {{ value = makeExpression(); }}
	expr6 = left:expr7 expr6_rest {{ value = makeExpression(); }}
	expr7 = left:expr8 expr7_rest {{ value = makeExpression(); }}
	expr8 = left:expr9 expr8_rest {{ value = makeExpression(); }}
	expr9 = left:expr10 expr9_rest {{ value = makeExpression(); }}
	expr10 = left:expr11 expr10_rest {{ value = makeExpression(); }}
	expr11 = left:expr12 expr11_rest {{ value = makeExpression(); }}
	expr12 = left:expr13 expr12_rest {{ value = makeExpression(); }}
	expr13 = unary* expr13_real {{ value = makeExpression(); }}

	expr_rest(left) = s "||" s right:expr2 new_left:{{ value = makeExpressionOr(left, right); }} expr_rest(new_left)
	                | <void> {{ value = left; }}
	expr2_rest(left) = s "^^" s expr3 expr2_rest(left)
	                 | <void> {{ value = left; }}
	expr3_rest(left) = s "&&" s right:expr4 new_left:{{ value = makeExpressionAnd(left, right); }} expr3_rest(new_left)
	                 | <void> {{ value = left; }}
	expr4_rest = s "|" s expr5 expr4_rest
	           | <void>
	expr5_rest = s "^" s expr6 expr5_rest
	           | <void>
	expr6_rest = s "&" s expr7 expr6_rest
	           | <void>
	expr7_rest = s ":=" s expr8 expr7_rest
	           | <void>
	# todo: fix expr8_rest
	expr8_rest = s "=" s expr9 expr8_rest
	           | s "!=" s expr9 expr8_rest
		   # todo: intervals
	           | <void>
	expr9_rest = s compare s expr10 expr9_rest
	           | <void>
	compare = "<="
		    | ">="
		    | "<"
	        | ">"
	all_compare = compare
	            | "="
		        | "!="
	expr10_rest = s "+" s expr11 expr10_rest
	            | s "-" s expr11 expr10_rest
		    | <void>
	expr11_rest = s "*" s expr12 expr11_rest
	            | s "/" s expr12 expr11_rest
	            | s "%" s expr12 expr11_rest
		    | <void>
	expr12_rest = s "**" s expr13 expr12_rest
	            | <void>
	unary = "!"
	      | "-"
	      | "~" !key !digit
	expr13_real = function
	            | value
	            | "(" s e:expr s ")" {{ value = e; }}

    function = "abs"{case} s "(" s expr s ")"
	         | "const"{case} s "(" s expr s ")"
		 | "selfanimexist"{case} s "(" s expr s ")"
		 | "ifelse"{case} s "(" s expr_c s "," s expr_c s "," s expr_c s ")"
		 | "gethitvar"{case} s "(" s expr_c s ")"
		 | "floor"{case} s "(" s expr_c s ")"
		 | "ceil"{case} s "(" s expr_c s ")"
		 | "sysvar"{case} s "(" s integer s ")"
		 | "var"{case} s "(" s integer s ")"
		 | "numexplod"{case} s "(" s integer s ")"
		 | "numhelper"{case} s "(" s integer s ")"
		 | "numprojid"{case} s "(" s integer s ")"
		 | "helper"{case} s "(" s integer s ")"
		 | "fvar"{case} s "(" s integer s ")"
		 | "target"{case} s "(" s integer s ")"
		 | "ishelper"{case} s "(" s integer s ")"
		 | "animelemtime"{case} s "(" s integer s ")"
		 | "animelemno"{case} s "(" s expr_c s ")"
		 | "animexist"{case} s "(" s expr_c s ")"
		 | "projguarded"{case} s "(" s expr_c s ")"
		 | "projcontact"{case} s "=" s integer function_rest
		 | "animelem"{case} s "=" s integer function_rest
		 | "numhelper"{case} s "(" s expr_c s ")"
		 | "helper"{case} s "(" s expr_c s ")"
	function_rest = s "," s all_compare s integer

	key = key_real key_rest
	key_rest = s "+" key_real key_rest
	         | <void>
	key_real = key_modifier* key_name
	key_modifier = "~" digit*
	             | "$"
		     | "/"
		     | ">"
	key_name = "DB"
		 | "B"
		 | "DF"
		 | "D"
		 | "F"
		 | "UF"
		 | "UB"
		 | "U"
		 | "a"
		 | "b"
		 | "c"
		 | "x"
		 | "y"
		 | "z"
		 | "s"

	value = float
	      | integer
	      | keyword
	      | !keyword identifier
	      | range
	      | string
	      | key
	
	keyword = keyword_real !alpha_digit
	keyword_real = "vel"{case} s "y"{case}
	             | "vel"{case} s "x"{case}
	             | "pos"{case} s "y"{case}
	             | "pos"{case} s "x"{case}
	             | "p2dist"{case} s "x"{case}
	             | "p2dist"{case} s "y"{case}
	             | "p1dist"{case} s "x"{case}
	             | "p1dist"{case} s "y"{case}
	             | "p2bodydist"{case} s "x"{case}
	             | "p2bodydist"{case} s "y"{case}
	             | "p1bodydist"{case} s "x"{case}
	             | "p1bodydist"{case} s "y"{case}
